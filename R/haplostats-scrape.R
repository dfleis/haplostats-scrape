#####################################################################################
#
# #### IMPORTANT NOTE ####
# If we wish to make repeated calls to the haplostats page in quick succession
# (e.g. through a loop) then it is worth looking at the 'polite' library to
# not risk overburdening the haplostats servers.
# ########################
#
# Scrapes data generated from the haplostats.org query page form. The
# first part sets the different arguments required by the haplostats 
# form. To see all the arguments required by the form print the results
# stored in the 'hapl.form' object.
#
# See README.md for more detailed notes on this script.
#
#####################################################################################
library(rvest)
library(xml2)    # xml2::as_list
library(stringr) # stringr::str_detect

#===== CREATE & LOOK AT THE HAPLOSTATS PAGE/FORM =====#
url          <- "https://haplostats.org/"

Sys.sleep(3 + runif(1))
hapl.session <- session(url)
hapl.form    <- html_form(hapl.session)
hapl.form


#===== ENTER HAPLOSTATS QUERY VALUES =====#
## "HLA Dataset"
# "84|NMDP.HIGHRES.1.1.0.2007-11-20|NMDP high res 2007"    # NMDP high res 2007
# "21|NMDP.FULL-COMPOSITE.1.1.0.2011-08-25|NMDP full 2011" # NMDP full 2011
dataset <- "21|NMDP.FULL-COMPOSITE.1.1.0.2011-08-25|NMDP full 2011"

## "Haplotype Loci"
# "A~C~B~DRBX~DRB1~DQB1" # A~C~B~DRBX~DRB1~DQB1
# "A~C~B~DRB1~DQB1"      # A~C~B~DRB1~DQB1
# "C~B"                  # C~B
# "A~C~B"                # A~C~B
# "A~B~DRB1"             # A~B~DRB1
# "A~C~B~DRB1"           # A~C~B~DRB1
haplotypeLoci <- "A~C~B~DRB1~DQB1" 

## "Populations"
# "AFA", "AAFA", "AFB", "CARB"
# "API", "AINDI", "FILII", "HAWI", "JAPI", "KORI", "NCHI", "SCSEAI", "VIET"
# "CAU", "MENAFC", "EURCAU", 
# "HIS", "CARHIS", "MSWHIS", "SCAHIS"
# "NAM", "AMIND", "CARIBI"
populations <- c("AFA", "AAFA", "AFB", "API", "SCSEAI", "CAU", "MSWHIS", "NAM")

# storing for later (if needed)
allpops <- c("AFA", "AAFA", "AFB", "CARB", 
             "API", "AINDI", "FILII", "HAWI", "JAPI", "KORI", "NCHI", "SCSEAI", "VIET",
             "CAU", "MENAFC", "EURCAU",
             "HIS", "CARHIS", "MSWHIS", "SCAHIS",
             "NAM", "AMIND", "CARIBI")

## "HLA type"
a1 <- "01:01"
a2 <- "01:02"
b1 <- "08:01"
b2 <- "08:01"
c1 <- NULL
c2 <- NULL
drb1_1 <- NULL#"03:01"
drb1_2 <- NULL#"15:01"
dqb1_1 <- NULL
dqb1_2 <- NULL
drb3_1 <- NULL
drb3_2 <- NULL
drb4_1 <- NULL
drb4_2 <- NULL
drb5_1 <- NULL
drb5_2 <- NULL

# storing HLA type inputs for later (not sure if it'll be useful, but just in case)
cleanvar <- function(x) ifelse(is.null(x), NA, x)
allhla.vec <- c(cleanvar(a1), cleanvar(a2), 
                cleanvar(b1), cleanvar(b2), 
                cleanvar(c1), cleanvar(c2), 
                cleanvar(drb1_1), cleanvar(drb1_2), 
                cleanvar(dqb1_1), cleanvar(dqb1_2), 
                cleanvar(drb3_1), cleanvar(drb3_2),
                cleanvar(drb4_1), cleanvar(drb4_2), 
                cleanvar(drb5_1), cleanvar(drb5_2))
allhla.tab <- matrix(allhla.vec, ncol = 2, byrow = T)
rownames(allhla.tab) <- c("A", "B", "C", "DRB1", "DQB1", "DRB3", "DRB4", "DRB5")

#===== FILL VALUES INTO THE HAPLOSTATS FORM & SUBMIT FORM =====#
# If we wanted to set values for the 'Population' checkboxes we would
# include those arguments here (although I haven't tested how to do so).
filled.form <- html_form_set(form = hapl.form[[1]], 
                             "dataset" = dataset,
                             "haplotypeLoci" = haplotypeLoci,
                             "a1" = a1,
                             "a2" = a2,
                             "b1" = b1,
                             "b2" = b2,
                             "c1" = c1,
                             "c2" = c2,
                             "populations" = populations,
                             "drb11" = drb1_1,
                             "drb12" = drb1_2,
                             "dqb11" = dqb1_1,
                             "dqb12" = dqb1_2,
                             "drb31" = drb3_1,
                             "drb32" = drb3_2,
                             "drb41" = drb4_1,
                             "drb42" = drb4_2,
                             "drb51" = drb5_1,
                             "drb52" = drb5_2)
hapl.page <- session_submit(x = hapl.session, form = filled.form, submit = "_eventId_success")

#===== EXTRACT DATA FROM PAGE GENERATED BY OUR SUBMISSION =====#
# structure whatever object submit_form creates to something more amenable to html parsing
hapl.html <- read_html(hapl.page) 

# After some googling I think want to use is 'CSS selectors' in parsing/navigating our HTML page.
# For example
#   * If we want to select elements with 'class="XYZ"' then we'd write ".XYZ", i.e. 
#     html_elements(hapl.html, ".display") will return elements of class=".display" (I think...).
#   * If we want to select elements with 'id="ABC"' then we'd write "#ABC", i.e.
#     html_elements(hapl.html, "#pairedFrequencies") will return elements of id="pairedFrequencies".
# See https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors for more details on
# these kinds of selectors and their notation (rvest "implements the majority of CSS3 selectors").

# PHASED GENOTYPES
hapl.elem.p <- html_elements(hapl.html, "#pairedFrequencies") 
# UNPHASED GENOTYPES
hapl.elem.u <- html_elements(hapl.html, "#mugFrequencies")

##############
############## Can be quite slow for large outputs 
###############
# if we want the 'raw text' instead of letting rvest try to automatically make it into a table
hapl.txt.p <- html_text2(hapl.elem.p) 
hapl.txt.u <- html_text2(hapl.elem.u)

# # try letting rvest put it in a table and see how well it does with the format
# # treat blank, "NA" and "N/A" cell values as NA
# hapl.tab.p <- html_table(hapl.elem.p, na.strings = c("", "NA", "N/A"))
# hapl.tab.u <- html_table(hapl.elem.u, na.strings = c("", "NA", "N/A"))

### As per the suggestion by William: Using the xml2 library (xml2::as_list)
### to extract the data into a less horrific format
#Extract the data from the element using xml2
data = unname(unlist(as_list(hapl.elem.u)))
# This identifies the beginning of blocks of haplotypes
resultIndex = which(data %in% 'HLA Type')

# A loop to paste together the results on each line
#not sure how it behaves with manycolumns of results
for (i in resultIndex){
  print(paste(c('Haplotype:',  paste(data[(i+3):(i+12)], collapse=' '), 
                'Type freq:',  as.numeric(data[i+13]), 
                'Likelihood:', as.numeric(strsplit(data[i+14], '%'))), collapse=' '))
}

####################### EXPLORING HOW TO CLEAN THE DATA #########################
### Building off William's suggestion
### Trying to further clean the data & place it into a unified data structure
###
### NOTES:
#   I noticed that if we leave the population checkboxes unspecified in our html_form_set() function
#   then the haplostats page seems to include all populations by default ("AFA", "AAFA", "AFB", etc..).
#   This seems to be one of the reason why so many entries appear to be returned when extracting the
#   output into a usable format.
#
# Note that the first entries in the datahead object below are exactly those populations we
# have specified (if we remove N/A value). Then it begins again and lists all possible
# populations.
#
# Notice that the cells contain "Likelihood" repeat in what appears to be regular (the regularity
# may depend on the number of populations specified by the user).
#
# Notice that the cells corresponding to the HLA "Likelihood" values will have a "%" in it.
# We can use this to extract other values. Let 'idx' correspond to an index of a "Likelihood"
# value, then
#   1) idx - 1 seems to be the location containing the "HLA type freq" values
#   2) idx - 2 to idx - 11 seems to be locations containing the HLA types. I **believe** it's 
#      separated over 10 indices because it splits (the 5 HLA names) x (the 2 types) into
#      distinct entries, i.e. it splits the 5 rows x the 2 types of each cell into different 
#       entries
# 
#
# OPEN QUESTIONS: How often to entries repeat? What cells to they correspond to?
# How does selecting different populations affect the indices?

# partition data into its header info and the "body"
data_raw <- unname(unlist(as_list(hapl.elem.u)))
row_idx  <- which(data_raw == "Likelihood") 
datahead <- data_raw[1:(row_idx[1])]    # save the header info cells if we need them later
data     <- data_raw[-(1:(row_idx[1]))] # remove the first cells that contain the header info/titles/etc

datahead
datahead_noNA <- datahead[datahead != "N/A"]
datahead_noNA

datahead[1:length(populations)]



data <- data[-(1:row_idx[1])]   
head(data, 100)


like_idx <- which(str_detect(data, "\\%")) 
hla_like <- as.numeric(gsub("%", "", data[like_idx])) # Likelihood
hla_freq <- as.numeric(data[like_idx-1])              # HLA type frequency
hla_raw  <- lapply(2:11, function(i) data[like_idx-i])

hla_like



hla_like
which(hla_like == 15.2)
tail(data)



hla_tmp <- data.frame(hla_freq, hla_like)
allpops
head(hla_like, 100)
head(hla_tmp, 50)

hla_like[seq(1, length(hla_like), 23)]

hla_tmp <- cbind(hla_like, hla_freq)
idx <- which(hla_freq == 13.7)
hla_tmp[31,] # every 10 values seems to give tthe displayed cells (not sure what the other 9 are)

hla_tmp[seq(1, nrow(hla_tmp), 10),]
head(hla_tmp, 30)


head(data, 100)


str(hla_raw)
hla_freq
hla_freq[seq(1, length(hla_freq), 5)]

head(data, 100)
which(data == "HLA Type")


udata <- unname(data)
udata
which(data == "HLA typing resolution score")-1
length(data)/length(populations)
length(data)/(length(allpops)+2)
length(data)/sum(is.na(allhla.vec))
sum(is.na(allhla.vec))
allhla.tab
length(data)/3
length(data)/37
allpops



### Building off William's suggestion
### Trying to further clean the data & place it into a unified data structure
###

resultList <- vector(mode = "list", length = length(resultIndex))
for (listidx in 1:length(resultIndex)) {
  i <- resultIndex[listidx]
  
  haplotype  <- data[(i+3):(i+12)]
  typefreq   <- as.numeric(data[i+13])
  likelihood <- as.numeric(strsplit(data[i+14], '%'))
  
  # split haplotype rows into the sections left and right of the "+"
  htypeL <- haplotype[seq(1, length(haplotype), 2)]
  htypeL <- gsub("\\+", "", htypeL) # remove the "+" which is appended on the left portion
  htypeR <- haplotype[seq(2, length(haplotype), 2)]
  
  resultList[[listidx]] <- list(haplotype  = unname(cbind(htypeL, htypeR)),
                                typefreq   = typefreq,
                                likelihood = likelihood)
}
# extract inner lists and place into their own data structures
haplotype  <- lapply(resultList, function(res) res$haplotype)
typefreq   <- sapply(resultList, function(res) res$typefreq)
likelihood <- sapply(resultList, function(res) res$likelihood)


head(haplotype)
likelihood

