#####################################################################################
#
# #### IMPORTANT NOTE ####
# If we wish to make repeated calls to the haplostats page in quick succession
# (e.g. through a loop) then it is worth looking at the 'polite' library to
# not risk overburdening the haplostats servers.
# ########################
#
# Scrapes data generated from the haplostats.org query page form. The
# first part sets the different arguments required by the haplostats 
# form. To see all the arguments required by the form print the results
# stored in the 'hapl.form' object.
#
# See README.md for more detailed notes on this script.
#
#####################################################################################
library(rvest)
library(xml2)    # xml2::as_list
library(stringr) # stringr::str_detect

#=============================================================================#
#================= CREATE & LOOK AT THE HAPLOSTATS PAGE/FORM =================#
#=============================================================================#
url          <- "https://haplostats.org/"

Sys.sleep(3 + runif(1))
hapl.session <- session(url)
hapl.form    <- html_form(hapl.session)
hapl.form

#=============================================================================#
#======================= ENTER HAPLOSTATS QUERY VALUES =======================#
#=============================================================================#
## "HLA Dataset"
# "84|NMDP.HIGHRES.1.1.0.2007-11-20|NMDP high res 2007"    # NMDP high res 2007
# "21|NMDP.FULL-COMPOSITE.1.1.0.2011-08-25|NMDP full 2011" # NMDP full 2011
dataset <- "21|NMDP.FULL-COMPOSITE.1.1.0.2011-08-25|NMDP full 2011"

## "Haplotype Loci"
# "A~C~B~DRBX~DRB1~DQB1" # A~C~B~DRBX~DRB1~DQB1
# "A~C~B~DRB1~DQB1"      # A~C~B~DRB1~DQB1
# "C~B"                  # C~B
# "A~C~B"                # A~C~B
# "A~B~DRB1"             # A~B~DRB1
# "A~C~B~DRB1"           # A~C~B~DRB1
haplotypeLoci <- "A~C~B~DRB1~DQB1" 

## "Populations"
# "AFA", "AAFA", "AFB", "CARB"
# "API", "AINDI", "FILII", "HAWI", "JAPI", "KORI", "NCHI", "SCSEAI", "VIET"
# "CAU", "MENAFC", "EURCAU", 
# "HIS", "CARHIS", "MSWHIS", "SCAHIS"
# "NAM", "AMIND", "CARIBI"
populations.raw <- c("AFA", "AAFA", "SCSEAI", "CAU", "CARHIS", "MSWHIS", "NAM", "HAWI", "JAPI", "VIET", "HIS", "CARIBI")

## "HLA type"
a1 <- "01:01"
a2 <- "01:02"
b1 <- "08:01"
b2 <- "08:01"
c1 <- NULL
c2 <- NULL
drb1_1 <- NULL#"03:01"
drb1_2 <- NULL#"15:01"
dqb1_1 <- NULL
dqb1_2 <- NULL
drb3_1 <- NULL
drb3_2 <- NULL
drb4_1 <- NULL
drb4_2 <- NULL
drb5_1 <- NULL
drb5_2 <- NULL

#==================================================================================#
#============ STORING VALUES NEEDED FOR PROCESSING THE FORM INPUT/OUTPUT ==========#
#==================================================================================#
# The tabindex label MUST be in the order of the population labels and can be found
# by 'Inspect'-ing the haplostats.org web form. To make this script more robust it would
# be a good idea to scrape the tabindex values directly from the webpage.
### 
### IMPORTANT: To reiterate the note immediately above, the order of the values in the
###            two vectors 'allpops' and 'allpops.tabindex' is exceedingly important.
###            The tabindex values must be in the same order as their population labels.
###
allpops <- c("AFA", "AAFA", "AFB", "CARB", 
             "API", "AINDI", "FILII", "HAWI", "JAPI", "KORI", "NCHI", "SCSEAI", "VIET",
             "CAU", "MENAFC", "EURCAU",
             "HIS", "CARHIS", "MSWHIS", "SCAHIS",
             "NAM", "AMIND", "CARIBI")
allpops.tabindex <- c("11", "12", "13", "14",
                      "16", "17", "18", "19", "20", "21", "22", "23", "24", 
                      "25", "26", "27", 
                      "28", "29", "30", "31",
                      "32", "34", "36")

# sort populations.raw in the ordering of the haplostats form (this will break if they change the ordering)
populations <- allpops[sort(unlist(sapply(populations.raw, function(pop) which(allpops == pop))))]


# By default the webform generated by 'html_form' automatically selects the checkboxes with
# some default populations. Although I can specify additional populations, I couldn't (yet) 
# figure out a way to de-select the default populations chosen by the form. A way around this
# was to manually remove objects corresponding to each checkbox of the old populations
# (hapl.form[[1]]$fields is a list, and each object within it named 'populations' is a
# selected population checkbox) and then place back into the form manually constructed 
# objects of the correct format/class, each under the label 'populations'.
pop.fields <- lapply(1:length(populations), function(popidx) {
  # construct objects corresponding to population checkbox to be included in our form
  pop         <- populations[popidx]
  allpops.idx <- which(allpops == pop)
  
  out <- list("type"  = "checkbox", 
              "name"  = "populations",
              "value" = pop,
              "attr"  = list(
                "tabindex" = allpops.tabindex[allpops.idx],
                "id"       = paste0("pop-", pop),
                "value"    = pop,
                "name"     = "populations",
                "type"     = "checkbox"
              ))
  class(out) <- "rvest_field"
  return (out)
})
# replace default population fields with our desired populations
# all other fields can be specified in a less hacky way
hapl.form.input <- hapl.form[[1]]
hapl.form.input$fields[names(hapl.form.input$fields) == "populations"] <- NULL

nfields       <- length(hapl.form.input$fields)
newfields.idx <- (nfields+1):(nfields+length(pop.fields))
hapl.form.input$fields[newfields.idx] <- pop.fields

# storing HLA type inputs for later (not sure if it'll be useful, but just in case)
cleanvar <- function(x) ifelse(is.null(x), NA, x)
allhla.vec <- c(cleanvar(a1), cleanvar(a2), 
                cleanvar(b1), cleanvar(b2), 
                cleanvar(c1), cleanvar(c2), 
                cleanvar(drb1_1), cleanvar(drb1_2), 
                cleanvar(dqb1_1), cleanvar(dqb1_2), 
                cleanvar(drb3_1), cleanvar(drb3_2),
                cleanvar(drb4_1), cleanvar(drb4_2), 
                cleanvar(drb5_1), cleanvar(drb5_2))
allhla.tab <- matrix(allhla.vec, ncol = 2, byrow = T)
rownames(allhla.tab) <- c("A", "B", "C", "DRB1", "DQB1", "DRB3", "DRB4", "DRB5")

#========================================================================#
#========== FILL VALUES INTO THE HAPLOSTATS FORM & SUBMIT FORM ==========#
#========================================================================#
filled.form <- html_form_set(form = hapl.form.input,
                             "dataset"       = dataset,
                             "haplotypeLoci" = haplotypeLoci,
                             "a1" = a1, 
                             "a2" = a2,
                             "b1" = b1,
                             "b2" = b2,
                             "c1" = c1, 
                             "c2" = c2,
                             "drb11" = drb1_1, 
                             "drb12" = drb1_2,
                             "dqb11" = dqb1_1, 
                             "dqb12" = dqb1_2,
                             "drb31" = drb3_1,  
                             "drb32" = drb3_2,
                             "drb41" = drb4_1,
                             "drb42" = drb4_2,
                             "drb51" = drb5_1,
                             "drb52" = drb5_2)
hapl.page <- session_submit(x = hapl.session, form = filled.form, submit = "_eventId_success")

#===== EXTRACT DATA FROM PAGE GENERATED BY OUR SUBMISSION =====#
# structure whatever object submit_form creates to something more amenable to html parsing
hapl.html <- read_html(hapl.page) 

# select sections of our html page using css selectors (found using the "SelectorGadget" extension)
# this particular selection scrapes elements from the "Unphased Genotypes" table
css_selector <- "#mugFrequencies tr:nth-child(1) tr td , #mugFrequencies td td"
hapl.elem <- html_elements(hapl.html, css = css_selector)

# retrieve underlying text from the html elements selected by html_elements()
hapl.text <- html_text(hapl.elem)

#=====================================================================================#

# Detect which cells contain "HLA Type" so that we can map the cells between
# "HLA Type" indices to individual "rows".
row.start.idx <- which(grepl("HLA Type", hapl.text))

header.idx     <- 1:(row.start.idx[1] - 1)
header         <- hapl.text[header.idx]
header.allpops <- header[!(header %in% c("", "N/A"))] # should be = populations, but we use this to ensure proper ordering

# Split the body of the text vector into a list in which each element is a row from the table.
row.list <- list()
if (length(row.start.idx) > 1) {
  for (i in 1:(length(row.start.idx)-1)) {
    # start + 3 to skip the three row labels (HLA Type, HLA type freq, Likelihood)
    row.list[[i]] <- hapl.text[(row.start.idx[i]+3):(row.start.idx[i+1] - 1)]
  }
  row.list[[i + 1]] <- hapl.text[(row.start.idx[i+1]+3):length(hapl.text)]
} else {
  row.list[[1]] <- hapl.text[(row.start.idx[1]+3):length(hapl.text)]
}


out.by.hla <- vector(mode = "list", length = length(row.list))
for (i in 1:length(out.by.hla)) { # Iterate through each of our "rows".
  row <- row.list[[i]]
  
  # We need to determine which populations the cells correspond to. If the population is non-empty
  # then a column spans 13 cells, if the population is empty then the column spans 4 cells.
  
  # Find entries with "%" in them (likelihood value), then 13 cells before that will define a column. 
  # However, if there is a column without a "%" (implying it's an empty column/population) then 4 
  # cells before it will define a column.
  pct.idx2 <- pct.idx <- which(grepl("%", row)) # create a copy that we can modify during our loop below
  
  # Find which cells containing "%" are located at an index divisible by 13 (then the pop is nonempty)
  # If it is not divisible by 13 is it the first one to be "not-divisible-by-13" by a multiple of 4 (then the pop is empty)
  # (i.e. if it the second pop to off being divisible by 13 by 4 then it is non-empty, but if it's the first
  # pop to be off being divisible by 13 by 8 then it is empty).
  # We check if it's divisible by 13, if not, check how many times subtracting by 4 would make it divisible by 13
  nonempty.pop.idx <- rep(NA, length(pct.idx2))
  for (k in 1:length(pct.idx2)) {
    count <- 0
    repeat {
      if (pct.idx2[k] %% 13 == 0) {
        nonempty.pop.idx[k] <- k + count
        break
      }
      count <- count + 1
      pct.idx2[k] <- pct.idx2[k] - 4
    }
  }
  row.nonempty.pops.cleaned <- header.allpops[nonempty.pop.idx]
  
  # For all non-empty cells, reconstruct the tables/data from the webpage in a more readable format
  row.tabs <- lapply(1:length(header.allpops), function(k) NA) # create empty list of tables with default value of NA
  names(row.tabs) <- header.allpops
  
  tabs.nonempty <- lapply(pct.idx, function(pidx) {
    row.sub <- row[(pidx-12):pidx]
    
    haplotype  <- matrix(gsub("\\+", "", row.sub[2:11]), ncol = 2, byrow = T)
    colnames(haplotype) <- c("Type1", "Type2")
    
    typefreq   <- as.numeric(row.sub[12])
    likelihood <- as.numeric(gsub("%", "", row.sub[13]))/100
    list("haplotype" = haplotype, "typefreq" = typefreq, "likelihood" = likelihood)
  })
  
  row.tabs[nonempty.pop.idx] <- tabs.nonempty
  out.by.hla[[i]] <- row.tabs
}


out.by.pops <- lapply(populations, function(pop) {
  sapply(out.by.hla, function(out) {
    out[names(out) == pop]
  })
})
names(out.by.pops) <- populations

###### display outputs/results
out.by.hla[[1]] # most common HLA, split by population
out.by.pops[["AFA"]] # list of HLA by population "AFA"
